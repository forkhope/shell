描述 grep 命令的使用
grep [OPTIONS] PATTERN [FILE...]
grep [OPTIONS] [-e PATTERN | -f FILE] [FILE...]
注意: grep命令的最后一个参数是文件名.如果没有提供文件名,将读取标准输入.

1.使用 "-r" 选项查找当前目录下的文件内容: grep -r "pattern" ./
-R,-r,--recursive: Read all files under each directory, recursively; this
is equivalent to the "-d recurse" option.
-------------- 另外,也可以使用grep "pattern" *命令来查找当前目录下的文件
内容,但是不会对目录进行递归.实际就是由Bash把'*'扩展为当前目录的所有文件名.

2.查找特定文件名的内容: find . -name "filename" | xargs grep "pattern"
例如查找所有C文件是否包含"ls": find . -name "*.c" | xargs grep "ls".这个
命令的匹配结果一般不带颜色高亮,如果想要颜色高亮,需要使用如下命令:
find . -name "*.c" | xargs grep --color=auto "ls".也就是用grep的--color选项

3.POSIX字符类: 用于匹配某类的特殊字符,如[:alnum:]是A-Za-z0-9的另一个写法.
要把它们放到[]号才能成为正则表达式,如[A-Za-z0-9]或[[:alnum:]].在Linux下,除
了fgrep外,grep, egrep, rgrep等命令都支持POSIX的字符类.
在grep中,要匹配A到Z之间的字符,要将"A-Z"放到方括号"[]"中,即写为"[A-Z]".实际
上,"[:alnum:]"是一个整体,这里的方括号"[]"并不是grep中要求的"[]",所以要在
grep中使用"[:alnum:]"时,要再加一个方括号,即写为"[[:alnum:]]".
在Debian上测试发现,在家目录下执行"grep [:alnum:] filename"命令是不会报错,能
正确匹配到内容,测试如下:
john:~$grep [:alnum:] Makefile      # 注意这里的目录是~,表示家目录
a: a.c
    gcc -Wall -o $@ $^
但是在其他非家目录下执行"grep [:alnum:] filename"命令时,会报错,提示如下:
john:/$grep [:alnum:] *             # 在根目录'/'下执行该命令会报错
grep: 字符类的语法是 [[:space:]],而非 [:space:]
john:~/source$grep [:alnum:] *      # 在家目录下的source下执行该命令也报错
grep: 字符类的语法是 [[:space:]],而非 [:space:]
目前尚不清楚这其中的差别是什么.但建议在grep中都写为"[[:alnum:]]"的形式.
>>>>>>>>>> 列举各个POSIX字符类如下 <<<<<<<<<<<<<<<<<<<<<<
[:alnum:]       文本数字字符
[:alpha:]       文本字符
[:digit:]       数字字符
[:graph:]       非空字符(非空格,控制字符)
[:lower:]       小写字符
[:cntrl:]       控制字符
[:print:]       非空字符(包括空格)
[:punct:]       标点符号
[:space:]       所有空白字符(换行,空格,制表符)
[:upper:]       大写字符
[:xdigit:]      十六进制数字(0-9,a-f,A-F)

4.使用 -A ,-B 或 -C 选项查看 grep 匹配行前后的内容.
-A NUM, --after-context=NUM: Print NUM lines of trailing context after
matching lines. With the -o or --only-matching option, this has no effect.
-B NUM, --before-context=NUM: Print NUM lines of leading context before
matching lines. With the -o or --only-matching option, this has no effect.
-C NUM, -NUM, --context=NUM: Print NUM lines of output context. With the -o
or --only-matching option, this has no effect.
即, -A 查看所匹配行后面的内容, -B 查看所匹配行前面的内容, -C 查看前后内容.
john:~$grep -A 3 else a.c     # 可以看到,使用 -A 3 选项,下面除了打印匹配
    else if (pid == 0) {      # else 的行之外,还打印了随后的三行.
        execl("b", "b", (char *)0);
        _exit(127);
    }
john:~$grep -B 3 else a.c     # 使用 -B 3 选项,除了打印匹配 else 的行之外,
        perror("error");      # 还打印了其上三行.
        return 1;
    }
    else if (pid == 0) {
john:~$grep -C 3 else a.c     # 使用 -C 3 选项,除了打印匹配 else 行,还打印
        perror("error");      # 了其上三行,随后三行.
        return 1;
    }
    else if (pid == 0) {
        execl("b", "b", (char *)0);
        _exit(127);
    }
john:~$grep -3 else a.c       # -C 3 选项也可以简写为 -3.
        perror("error");
        return 1;
    }
    else if (pid == 0) {
        execl("b", "b", (char *)0);
        _exit(127);
    }
