一. 参数个数计算
Bash中,可以使用 $# 来获取传入的命令行参数或者函数参数个数.但要注意, $#
的值是不计算脚本本身的,如 ./a.sh a b,则 $# 是2,而不是3.这和C语言不同.

二. 位置参数
假设执行 ./a.sh a b c 这样一个命令,则
$0: 将返回"./a.sh". 如果执行的是"./work/a.sh", 则返回"./work/a.sh",而
    不是只返回路径后面的部分.
$1: 将返回a, 即 $1 返回脚本的第一个参数.
$2: 将返回b, 即 $2 返回脚本的第二个参数,以此类推.
$#: 将返回3, 参数个数,不包括 $0.
$@: 将返回a b c, 参数本身的列表,也不包括 $0.
$*: 也返回a b c, 返回值和$@类似,但"$*"和"$@"(加双引号)有所不同."$*"将所有
    参数解释成一个字符串,而"$@"是一个参数数组.举例如下:
有这样一个函数
function show
{
    for arg in "$*"; do
        echo $arg
    done
    echo --------------
    for arg in "$@"; do
        echo $arg
    done
}
则执行 show tian xia you qing ren, 会输出:
tian xia you qing ren
-----------------
tian
xia
you
qing
ren
即, "$*"只产生一个字符串,而"$@"产生了多个字符串,是一个参数数组.

注意:如果传入的参数多于9个,则不能使用$10来引用第十个参数.而是需要处理或保存
第一个参数($1)然后使用shift命令删除第一个参数并将所有剩余的参数下移一位,因
此$10就变成了$9,以此类推. $#的值将被更新以反映参数的剩余数量. 经过验证,发现
$10会被解释成${1}0,也就是$1的值再跟上0,如果$1是"tian",则$10的值是"tian0".

三. 参数选项解析
1. 使用Bash内置命令getopts来解析参数选项.
getopts: getopts optstring name [arg]
getopts is used by shell procedures to parse positional parameters.
optstring contains the option characters to be recognized; if a character
is followed by a colon, the option is expected to have an argument, which
should be separated from it by white space. The colon and question mark
characters may not be used as option characters. Each time it is invoked,
getopts places the next option in the shell variable name, initializing
name if it does not exist, and the index of the next argument to be
processed into the variable OPTIND. OPTIND is initialized to 1 each time
the shell or a shell script is invoked. When an option requires an argument,
getopts places that argument into the variable OPTARG. The shell does not
reset OPTIND automatically; it must be manually reset between multiple
calls to getopts within the same shell invocation if a new set of
parameters is to be used.
When the end of options is encountered, getopts exits with a return value
greater than zero. OPTIND is set to the index of the first non-option
argument, and name is set to ?.
getopts can report errors in two ways. If the first character of optstring
is a colon, silent error reporting is used. In normal operation diagnostic
messages are printed when invalid options or missing option arguments are
encountered. If the variable OPTERR is set to 0, no error messages will be
displayed, even if the first character of optstring is not a colon.
If an invalid option is seen, getopts places ? into name and, if not silent,
prints an error message and unsets OPTARG. If getopts is silent, the option
character found is placed in OPTARG and no diagnostic message is printed.
If a required argument is not found, and getopts is not silent, a question
mark (?) is placed in name, OPTARG is unset, and a diagnostic message is
printed. If getopts is silent, then a colon (:) is placed in name and
OPTARG is set to the option character found.
getopts returns true if an option, specified or unspecified, is found. It
returns false if the end of options is encountered or an error occurs.
即,每调用一次getopts,它只解析一个选项,并把解析的值存入变量name中.如果所给选
项不包含在optstring中,则变量name的值被设成'?'.所以,如果要解析多个选项时,需
要在while,或者for循环中执行getopts命令,来逐个解析参数选项,直到解析完毕为止.
注意: getopts在解析选项时,所输入的选项要求以'-'开头.例如有这样的语句:
    getopts "abc" arg; echo $arg
假设脚本名字是test.sh,则执行 ./test.sh a 会输出'?',虽然 a 在参数选项
"abc"里面,但是getopts解析选项时,要求选项以'-'开头.执行./test.sh -a就会
输出a.而执行./test.sh -abc,只会输出a,这是因为getopts执行一次,只解析一个选
项.执行 ./test.sh -d 时,会打印一个错误信息"./test.sh: 非法选项 -- d",然后再
换行输出'?'.根据上面的描述,可以知道此时getopts报告错误的方式是非安静模式,当
写为getopts ":abc" arg; echo $arg时,getopts报告错误的方式就是安静模式,此时
执行./test.sh -d就只会输出一个'?'. 另外,执行./test.sh也会输出'?',即不提供选
项时,getopts也是会报错,如上所述,getopts在遇到选项末尾时是报错的.
(1) 怎样来区分getopts是遇到了错误还是遇到了选项末尾呢? 可以使用如下方法:
while getopts "abcd" arg; do
    echo $arg
done
echo $OPTIND, $#
if [ "$(($OPTIND - 1))" != "$#" ]; then
    # 此时getopts遇到了错误, 进行出错处理
fi
经过验证,执行./test.sh -a,则$OPTIND的值是2,执行./test.sh -a -b -c,则$OPTIND
的值是4,执行./test.sh -abc,则$OPTIND的值也是2,执行./test.sh -a f,则$OPTIND
的值是2,执行./test.sh f,则$OPTIND的值是1. 可以看到,当正常遇到选项末尾时,
$OPTIND的值是选项总数加1,当遇到错误时,$OPTIND的值保持不变,所以当$OPTIND的
值减去1,不等于$#的值时,就表示遇到了错误.
(2) 如上所述,找到错误的选项,getopts也是会返回成功.例如把脚本改成:
getopts "abc" arg
if [ "$?" == "0" ]; then
    echo getopts return success: $arg
else
    echo getopts return fail: $arg
fi
则执行 ./test.sh a 会返回: getopts return fail: ?
而执行 ./test.sh -d会返回: ./test.sh: 非法选项 -- d
                           getopts return success: ?
可见,即使是找到一个无效选项,getopts也是返回的成功.
(3) 如上所述,当某个选项后面跟着':'时,表示它接受一个参数,解析结束后,该参数
会被存入变量OPTARG中. 例如有这样一个脚本test.sh:
getopts "e:" arg
echo $arg, $OPTARG
则执行./test.sh -e tian, 会输出e, tian. 而执行./test.sh -e会报错.
(4) 上面提到,当shell或者shell脚本被调用时,OPTIND会被初始化为1.当getopts遇到
选项末尾时,OPTIND的值是第一个非选项参数的index. 下面有一种情况要注意:
假设有一个shell脚本test.sh,其内容为:
echo $#, $@, $OPTIND
getopts "abc" opt
echo $?, $opt
则执行./test.sh -a会输出1, -a, 1 (换行) 0, a. 执行./test.sh -b会输出
1, -b, 1 (换行) 0, b. 这是正常的.然后执行source ./test.sh -a会输出
1, -b, 2 (换行) 1, ?, 接着再执行source ./test.sh -b会输出1, -b, 2 (换行)
1, ?. 可以看到,虽然提供了正确的选项-b,但是getopts返回的是假,解析不到选项.
此后,用source命令执行test.sh脚本时,getopts始终会返回假,$OPTIND的值一直是2,
没有重新被初始化为1! 所以,如果一个脚本执行了getopts命令,而该脚本又要用
source命令来执行时,脚本需要手动设置OPTIND变量的值为1,否则会导致上述情况.

四. 含有空格的参数
由于Bash中各个参数之间默认用空格隔开,当参数本身就带有空格时,这个参数要用
双引号或者单引号括起来,否则该参数会被按照空格隔开,视为多个参数. 例如:
john:~$function pr() { echo 1: $1; echo 2: $2; }
john:~$pr tian xia    # tian 和 xia 之间有空格,它们被视作两个参数
1: tian
2: xia
john:~$pr "tian xia" "you qing ren"   # 把"tian xia"放到双引号里面,就变成
1: tian xia                           # 一个参数
2: you qing ren
为了避免遇到这种错误,要求在给脚本或函数传递参数时,每个参数都使用双引号.

五.
