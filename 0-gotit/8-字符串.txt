一. 模式匹配操作符
查看man bash手册,里面对 ${parameter#word}, ${parameter##word} 的描述为:
Romove matching prefix pattern. The work is expanded to produce a pattern
just as in pathname expansion. If the pattern matches the beginning of the
value of parameter, then the result of the expansion is the expanded value
of parameter with the shortest matching pattern (the '#' case) or the
longest matching pattern (the '##' case) deleted. If parameter is @ or *,
the pattern removal operation is applied to each positional parameter in
turn, and the expansion is the resultant list. If parameter is an array
variable subscripted with @ or *, the pattern removal operation is applied
to each member of the array in turn,and the expansion is the resultant list

1. ${varname#pattern}: 如果pattern匹配变量varname值的开始部分,删除最小的
匹配部分并返回变量剩余部分内容.
注意,上面描述所说的"开始部分"是指pattern会跟varname从头开始比较,而不是在
varname中任意匹配pattern.假设有一个good="tian/xia/you/qing/ren"变量,则:
(1) echo ${good#tian} 会输出 "/xia/you/qing/ren".
(2) echo ${good#xia} 会输出 "tian/xia/you/qing/ren",即此时最小匹配为空.
(3) echo ${good#*xia} 会输出 "/you/qing/ren",即如果想在varname的中间部分
匹配pattern,可以在pattern中使用通配符,跳过varname的前面部分.
2. ${varname##pattern}: 如果pattern匹配变量varname值的开始部分,删除最大的
匹配部分并返回变量剩余部分内容.

上面所说的"最小匹配","最大匹配"主要是针对有多个匹配的情况而言.同样以上面的
good变量为例,则echo ${good#*/}输出xia/you/qing/ren,而echo ${good##*/}输出
ren. 简单来说,如果varname中有多个地方匹配pattern,则最小匹配是指在第一次匹
配时就停止匹配,并返回剩余的内容,而最大匹配会一直匹配到最后一次匹配为止,才
返回剩余的内容.又如good="tianxia youtian tianming",则echo ${good#*tian}输
出xia youtian tianming,而echo ${good##*tian}输出ming.

另外,这里说的"匹配"是全匹配,而不是部分匹配,它是要求pattern扩展之后得到的
字符串符合varname的内容,而不是在varname里面查找pattern字符串,上面的例子中,
echo ${good##*tian}会输出ming,但是echo ${good##tian}会输出xia youtian
tianming.它依然只匹配了开头的tian. 原因就在于,它不是在good变量里面查找tian
这个子字符串,而是把tian和good变量从头开始,挨个字符进行匹配,实际上就只匹配
了一次. 而在${good##*tian}表达式中,"*tian"会进行扩展,则在good变量中存在多个
地方匹配这个扩展, tian, tianxia youtian, tianxia youtian tian, 去掉最大的
匹配后,就只剩下ming,所以 ${good##*tian} 打印出来是ming.注意体会其中的区别.

查看man bash手册,里面对 ${parameter%word}, ${parameter%%word} 的描述为:
Remove matching suffix pattern. The word is expanded to produce a pattern
just as in pathname expansion. If the pattern matches a trailing portion of
the expanded value of parameter, then the result of the expansion is the
expanded value of parameter with the shortest matching pattern (the '%'
case) or the longest matching pattern (the '%%' case) deleted. If parameter
is @ or *, the pattern removal operation is applied to each positional
parameter in turn, and the expansion is the resultant list. If parameter is
an array variable subscripted with @ or *, the pattern removal operation is
applied to each member of the array in turn, and the expansion is the
resultant list. 即,这两个表达式匹配变量parameter的结尾部分,从后往前匹配.
3. ${parameter%word}: 如果pattern匹配变量varname值的结尾部分,删除最小的匹配
部分并返回变量剩余部分.即从parameter的末尾就开始匹配,并不是在parameter的任
意位置匹配word. 其所谓的"最小匹配"就是从后往前匹配,一匹配到就结束匹配.
4. ${parameter%%word}: 如果pattern匹配变量varname值的结尾部分,删除最大的匹
配部分并返回变量剩余部分.所谓"最大匹配"就是从后往前匹配,一直匹配到最后一次
匹配为止. 例如,有一个good="xiatianming/youtian/mingtian"变量, 则:
(1) echo ${good%ming} 会输出xiatianming/youtian/mingtian,看起来good中两个
地址出现了ming,应该能匹配到,其实匹配不到,因为good的末尾并不是ming,而该表达
式从末尾就开始匹配,匹配不到就认为失败,所以如果要想匹配到ming,good变量必须
以ming结尾. 这一点和上面的${param#word}是类似,${param#work}从头就开始匹配.
(2) echo ${good%tian} -- ${good%tian*} 会输出:
xiatianming/youtian/ming -- xiatianming/youtian/ming
(3) echo ${good%%tian} -- ${good%%tian*} 会输出:
xiatianming/youtian/ming -- xia
关于在匹配时,"tian"和"tian*"的区别可以参考更上面的描述,情况是类似的.

二. 获取字符串的长度
${#parameter}: Parameter length. The length in characters of the value of
parameter is substituted. If parameter is * or @, the value substituted is
the number of positional parameters. If parameter is an array name
subscripted by * or @, the value substituted is the number of elements in
the array. 即该表达式可以计算字符串的长度和数组元素的个数. 例如:
str="tian xia"; echo ${#str} 会输出 8.
如上所述,${#@}和${#*}会返回位置参数的个数,假设有一个test.sh脚本,其内容为:
echo ${#@} -- ${#*}
则执行./test.sh 1 2 3,会输出3 -- 3,执行./test.sh 1 2 3 4,会输出4 -- 4.
当parameter是数组名时,${#parameter[@]}或者${#parameter[*]}会打印数组元素
个数.例如,执行array=(1 2 3);echo ${#array[@]}--${#array[*]}, 会输出3--3.

三. 获取子字符串在字符串中的位置
可以使用 expr index STRING CHARS 命令来获取CHARS对应的子字符串在字符串中的
位置.显然,当传入的子字符串只有一个字符时,就是获取单个字符在字符串中的位置.
下面是几个例子,注意,当STRING中包含空格时,要用双引号括起来,否则报错.
john:~$str="tian xia - you qing ren"
john:~$expr index $str "t"    # str字符串中包含有空格,当$str不加双引号时,
expr: non-integer argument    # 执行expr index命令报错
john:~$expr index "$str" "t"  # 当$str添加了双引号后,就不会报错了
1
john:~$expr index "$str" "-"
10
john:~$expr index "$str" "p"  # 当传入的字符在字符串中不存在时,返回0
0
john:~$expr index "$str" "you"
12

四. 大小写转换
查看man bash手册,在"Parameter Expansion"小节中提到了字符串的大小写转换:
${parameter^pattern}, ${parameter^^pattern}
${parameter,pattern}, ${parameter,,pattern}
   Case modification. This expansion modifies the case of alphabetic
   characters in parameter. The pattern is expanded to produce a pattern
   just as in pathname expansion. The ^ operator converts lowercase letters
   matching pattern to uppercase; the , operator converts matching uppercase
   letters to lowercase. The ^^ and ,, expansions convert each matched
   character in the expanded value;	the ^ and , expansions match and convert
   only the first character in the expanded value. If pattern is omitted, it
   is treated like a ?, which matches every character. If parameter is @ or
   *, the case modification operation is applied to each positional
   parameter in turn, and the expansion is the resultant list. If parameter
   is an array variable subscripted with @ or *, the case modification
   operation is applied to each member of the array in turn, and the
   expansion is the resultant list.
即,这四个表达式在"parameter"中查找"pattern"模式,如果找到,就对它进行大小写转
换,如果省略"pattern",就表示匹配每一个字符,会替换整个字符串. 注意:"pattern"
会进行pathname expansion,这个步骤很重要,可以用于匹配多个字符,直接将pattern
中写为字符串是不起作用的.举例如下:
john:~$tian="youYiTianXiaTian"
john:~$echo ${tian^y} # 如上所述, 如果匹配, '^' 会替换parameter中的第一个字
YouYiTianXiaTian      # 符. !!注意!!: 不是替换第一个匹配到的字符,而是只替换
john:~$echo ${tian^i} # parameter的首字符.所以这个语句不会替换"$tian"中字符
youYiTianXiaTian      # 'i',因为'i'并不是"$tian"的首字符,'y'才是.
john:~$echo ${tian^^i}  # 此时,可以使用'^^'来替换parameter中每一个匹配的字
youYITIanXIaTIan      # 符,这个语句将"$tian"中的所有'i'都替换成了'I'.
john:~$echo ${tian^yo}  # 实际验证发现,不管用'^'还是'^^',将"pattern"写成字
youYiTianXiaTian      # 符串都会无法匹配.这两个语句的输出内容和$tian是一样
john:~$echo ${tian^^yo} # 的,没有进行任何替换.
youYiTianXiaTian      # 如果想替换多个字符,需要使用'[]'来进行pathname
john:~$echo ${tian^[yo]}  # expansion,得到多个可匹配的字符.例如,[yo]表示匹
YouYiTianXiaTian      # 配'y'或者'o'.此时,还必须使用'^^',如果使用'^',还是只
john:~$echo ${tian^^[yo]} # 会替换parameter的首字符.所以,'^[yo]'只替换了首
YOuYiTianXiaTian      # 字符'y'为'Y',而'^^[yo]'替换了所有'y','o'为'Y','O'.
john:~$echo ${tian^^[ia]} # 这个语句匹配所有'i'和'a'字符,并替换为'I'和'A'.
youYITIAnXIATIAn      # 替换的时候,并不要替换parameter中连在一起的字符.下面
john:~$echo ${tian^^[in]} # 的'i'和'n'在$tian中是不相连的,也能一起进行替换.
youYITIaNXIaTIaN
john:~$echo ${tian^^} # 如果省略"pattern",则会替换每一个字符,从而替换整个
YOUYITIANXIATIAN      # 字符串.
john:~$echo ${tian,,}
youyitianxiatian
john:~$echo ${tian^^?} # 将 "pattern" 写成 '?' 或者 '*',也能起到替换整个
YOUYITIANXIATIAN       # 字符串的效果.
john:~$echo ${tian^^*}
YOUYITIANXIATIAN

另外,还可以使用 declare 来进行大小写赋值,起到大小写转换的效果:
declare -l: When the variable is assigned a value, all upper-case
    characters are converted to lower-case.
declare -u: When the variable is assigned a value, all lower-case
    characters are converted to upper-case.
john:~$tian="TianXia"
john:~$declare -l lower=$tian # 将lower声明为小写变量,并赋值给它.
john:~$echo $lower            # 输出lower变量的值,可以看到是全小写.
tianxia
john:~$declare -u upper=$tian # 将upper声明为大写变量,并赋值给它.
john:~$echo $upper            # 输出upper变量的值,可以看到是全大写.
TIANXIA

五. 判断字符串是否全是数字
当使用 =~ 操作符时,其右边待比较的字符串被认为是一个扩展正则表达式.下面尝试
使用这个操作符来判断一个字符串是否全是数字.
(1) 方式一:
john:~/download$estimate_digit()
> {
> if [[ "$1" =~ [0-9] ]]; then
> echo "全是数字"
> else
> echo "不全是数字"
> fi
> }
john:~$estimate_digit 1
全是数字
john:~$estimate_digit a
不全是数字
john:~$estimate_digit 1a
全是数字
john:~$estimate_digit a1
全是数字
-----------------------------
可以看到,这个判断不准确,[0-9]只表示一个数字字符,上面的语句也只判断字符串的
第一个字符是否为数字,如果是,就认为是全数字,如果不是,就认为不全是数字.

(2) 方式二:
john:~$estimate_digit()
>  {
> if [[ "$1" =~ [0-9]* ]]; then
> echo "全是数字"
> else
> echo "不全是数字"
> fi
> }
john:~$estimate_digit 1
全是数字
john:~$estimate_digit a
全是数字
john:~$estimate_digit 1a
全是数字
john:~$estimate_digit a1
全是数字
-------------------------------
这里使用 [0-9]* 来表示零个或多个数字字符.但是判断还是不准确.上面的语句错误
地认为"a1","1a"都是全数字.原因在于,'=~'操作符是在左边字符串中匹配右边的正则
表达式,如果匹配,就认为匹配成功,[0-9]*表示要匹配零个或任意个数字字符,而在
"1a"和"a1"中,确实存在一个数字字符,所以匹配成功.
而程序原本的意图是判断所有的字符是否都是数字,代码作用和程序意图不符.
例如对方式二的 estimate_digit() 函数做如下的改动:
john:~$estimate_digit()
> {
> if [[ "$1" =~ [0-9][0-9] ]]; then
> echo "全是数字"
> else
> echo "不全是数字"
> fi
> }
john:~$estimate_digit 1a
不全是数字
john:~$estimate_digit a1
不全是数字
john:~$estimate_digit 11
全是数字
----------------------------------------------
可以看到,现在"1a"和"a1"不再认为是全数字.因为[0-9][0-9]明确要求匹配两个数字
字符,这和[0-9]*不同.

(3) 方式三:
结合上面的例子,要判断字符串是否全是数字,则所给的正则表达式必须精确匹配字符
串中的每一个字符,不能只匹配其中一个或几个,否则所匹配的字符个数可能少于字符
串长度,出现字符串中多出来的字符没有被匹配,导致匹配结果出错的情况.
修改后的 estimate_digit() 函数如下.正则表达式X{n}表示精确匹配n个字符X.下面
先获取所给字符串的长度,然后使用正则表达式[0-9]{字符个数}来精确匹配字符串中
的每个字符,看是不是数字.
john:~$estimate_digit()
> {
> local count=${#1}
> if [[ "$1" =~ [0-9]{${count}} ]]; then
> echo "全是数字"
> else
> echo "不全是数字"
> fi
> }
john:~$estimate_digit a1
不全是数字
john:~$estimate_digit 111
全是数字
john:~$estimate_digit 1a1
不全是数字
-------------------------------
可以看到,这次的判断结果是正确的.

六.使用 [ 命令来判断字符串是否为空
当使用 [ 的 -n, -z 来判断字符串是否为空,参数一定要用双引号括起来.例如:
在下面的函数中,分别对不带双引号的参数和带有双引号的参数进行判断.同样是
使用 -n, -z, 带或不带双引号,判断结果不一样.带双引号时,判断结果才是正确的.
john:~$whether_empty()
> {
> if [ -n $1 ]; then
> echo "no quote: not empty"
> fi
> if [ -z $1 ]; then
> echo "no quote: empty"
> fi
> if [ -n "$1" ]; then
> echo "quote: not empty"
> fi
> if [ -z "$1" ]; then
> echo "quote: empty"
> fi
> }
# 可以看到,当第一个参数不为空时,带不带双引号,判断结果都正确.
john:~$whether_empty tian
no quote: not empty
quote: not empty
# 此时没有提供第一个参数,则第一个参数为空,当 -n, -z 后面的参数不带双引号时,
# 它即认为这个参数不为空,也认为这个参数为空.而带有双引号时只判断为空.
john:~$whether_empty
no quote: not empty
no quote: empty
quote: empty
出现上述的原因在于, -n 或者 -z 是判断字符串是否为空字符串,空字符串指的是"".
当上面不提供第一个参数时, $1 扩展得到的结果并不是"",而是什么都没有.使用"$1"
时,得到的扩展结果才是"", -n 或者 -z 才能对该参数进行正确的判断.

七.
