一. 执行其他脚本
在脚本中执行其他脚本,跟执行其他命令是一样的.直接使用就行.例如,要在a.sh中
执行当前目录下的b.sh,直接写./b.sh就可以.如果需要参数,可以写为./b.sh arg1
当这样写的时候,当前脚本会启动一个子进程来执行这个脚本.
注意一下, ./b.sh 和 source ./b.sh 的区别. 前者在b.sh中执行exit,不会导致
当前脚本退出,后者在b.sh中执行exit,则会导致当前脚本也退出,也就是执行结束.

二. 用 source 调用其他脚本
可以使用source命令或者 . 命令来在当前脚本进程中执行其他脚本.source命令和.命
令是同一个命令,"help source"打印的帮助信息和"help ."打印的帮助信息是一样的.
source filename [arguments]
    Execute commands from a file in the current shell.
    Read and execute commands from FILENAME in the current shell. The
    entries in $PATH are used to find the directory containing FILENAME.
    If any ARGUMENTS are supplied, they become the positional parameters
    when FILENAME is executed.
    Exit Status:
    Returns the status of the last command executed in FILENAME; fails if
    FILENAME cannot be read.
(1)当使用source命令调用其他脚本时,由于该脚本是在当前脚本下执行的,则当该
脚本执行了exit语句时,不但该脚本会退出,调用该脚本的那个脚本也会退出.假设脚
本A调用了脚本B,如果不想脚本B的执行状态影响到脚本A的执行状态,那么慎重在脚本
B中执行exit语句.

(2)假设脚本A用source引用脚本B,最好把脚本B放在$PATH目录中,这样在任意地方
执行脚本A时,都能正确找到脚本B.

(3)假设脚本A用source引用脚本B,那么脚本B代码里面的$#是脚本A的参数个数,还是
在引用脚本B时的参数个数? 答案是,视具体情况而定. 描述如下:
1. 如果脚本A用source引用脚本B时,没有传递参数给脚本B,那么脚本B中的$#是脚本A
的参数个数.例如执行source ./b.sh,那么b.sh中打印出的$#的值是脚本A的参数个数.
2. 如果脚本A引用脚本B时,传了参数给脚本B,那么脚本B中的$#就是脚本A传递给脚本B
的参数个数. 例如执行source ./b.sh 1 2 3,那么b.sh打印出的$#的值是 3,如果执行
source ./b.sh 1 2 3 4,那么b.sh打印出的$#的值是 4.

(4)用source执行脚本时,脚本中的全局变量会保存在shell里面,脚本执行结束后,全局
变量的值还在,下次执行时如果没有重新赋值,这个值不会变.即,这些全局变量变成了
shell的全局变量,注意,不是环境变量. 假设有一个test.sh脚本如下:
test_var1="tian"
if [ "$#" == "1" ]; then
    test_var1="xia"
    test_var2="youqingren"
fi
echo "In the test.sh: ${test_var1}, ${test_var2}"
则在shell中用source命令执行该脚本,如下:
$source ./test.sh       # 用source命令在shell中执行脚本
In the test.sh: tian,  
$echo ${test_var1} -- ${test_var2}  # 之后,在shell中打印
tian --                 # test.sh脚本中的全局变量的值,发现它们的值还在
$source ./test.sh 1     # 再次执行test.sh脚本,改变里面的
In the test.sh: xia, youqingren         # 全局变量的值,其值已经改变.
$echo ${test_var1} -- ${test_var2}  # 再在shell中打印
xia -- youqingren       # test.sh脚本中的全局变量的值,发现它们的值也变了

三. 调试其他脚本的函数
如果要调用其他脚本的函数,有如下几种方式:
1. 在当前脚本中使用source或者 . 命令执行其他脚本,之后就可以直接调用那个脚
本的函数.此时,当前脚本和要调用的脚本位于同一个进程.
2. 假设要调用funcs.sh脚本里面的函数,则该脚本可以接收一个或多个参数,指定要
调用的函数名,然后funcs.sh脚本自己执行这些函数即可.此时,当前脚本是所要调用
脚本的父进程,两者是父子进程的关系. 举例如下:
# 这是 funcs.sh 脚本
function show_args()
{
    echo "The arguments are: $@"
}

# man bash手册对 "cmd1 && cms2" 和 "cmd1 || cmd2" 类型语句的描述如下:
# AND and OR lists are sequences of one of more pipelines separated by the
# && and || control operators, respectively. AND and OR lists are executed
# with left associativity. An AND list has the form "command1 && command2".
# command2 is executed if, and only if, command1 returns an exit status
# of zero. 即,command1执行正常时才会执行command2.
# An OR list has the form "command1 || command2". command2 is executed if
# and only if command1 returns a non-zero exit status. 即,当command1执行
# 出错时才会执行command2. The return status of AND and OR lists is the
# exit status of the last command executed in the list.
# 在下面这条语句中,当传入的第一个参数不为空时,"$1" = "" 就为假,然后执行
# $1 所指定的命令.如果传入的$1等于"show_args",那么就会执行该函数,从
# 而起到调用 funcs.sh 脚本的 show_args函数 的效果.
[ "$1" = "" ] || $1 $@

# 这是 call_funcs.sh 脚本
#!/bin/bash
./funcs.sh show_args 1 2 3
则执行 call_funcs.sh 脚本会输出: The arguments are: show_args 1 2 3

注意: 假设在"~/.bashrc"文件中添加"source funcs.sh"语句,之后就可以在终端中
直接调用 show_args() 函数,但是测试发现,在其他脚本中调用该函数会报错,提示"
show_args: 未找到命令".即,对终端的子进程来说,show_args()函数还是不可见的.
