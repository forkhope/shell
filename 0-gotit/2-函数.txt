一. 定义函数.
Bash中,定义函数时, function 关键字是可选的,查看man bash手册,可以看到其
定义函数的格式为:
name () compound-command [redirection]
function name [()] compound-command [redirection]
从中可以看到,当不写function关键字时,函数名一定要跟着小括号(),而写了
function关键字时,小括号是可选的.
关于compound-command的说明,同样可以查看man bash手册,里面大概提到几种形式:
A compound command is one of the following:
(list) list is executed in a subshell environment. Variable assignments
       and builtin commands that affect the shell's environment do not
       remain in effect after the command completes. The return status is
       the exit status of list.
{ list; } list is simply executed in the current shell environment. list
       must be terminated with a newline or semicolon. The return status is
       the exit status of list.
       注意:这里list后面一定要跟着分号';',而且"list;"和大括号之间要有空格,
       如果写为 {list;} 会报错.

二. 函数返回值
Bash要求返回值必须为一个整数,不能用 return 语句返回字符串变量,该整数返回
值为0表示函数执行成功,非0表示执行失败. 在函数中,执行return语句退出函数,
执行exit语句则会退出整个脚本,而不是只退出函数.
(1)函数用return返回,只能返回整数,如果要返回字符串,可以用echo来实现,就是
在函数内部打印字符串,然后调用者获取标准输出获取到打印的字符串,如下:
function foo() { echo "foo"; return 0; }; var=$(foo); echo ${var}, $?
执行上面语句,将会打印出foo, 0
注意:此时看起来,函数返回了两个值,一个是$(foo)会获取函数的标准输出,另一个
是$?会获取函数通过return语句返回的0,要区分这两个值的区别.如果在函数中写
为return 1, 那么上面的 $? 打印的出来的值是 1. 另外,注意一下如下的语句:
foo() { echo "foo"; }; bar() { foo; }; foobar() { a=$(foo); }
var=$(foo); echo first: ${var}
var=$(bar); echo second: ${var}
var=$(foobar); echo third: ${var}
执行这部分语句,会输出
first: foo
second: foo
third:
即, foo()函数将字符串写到标准输出,bar()函数调用了该函数,但是没有读取这个
标准输出,则这个标准输出会被bar()继承,就好象这个标准输出是由bar()函数输出
一样.而foobar()函数读取了这个标准输出,此时再通过$(foobar)来获取标准输出,将
获取到空,因为foo()函数中的标准输出给foobar()读走了.
这个做法有个缺陷,就是不能再在函数里面执行echo语句来打印调试信息,不然会导致
读到的标准输出混乱,有用的结果和调试信息都混在一起.

(2) 可以使用 $? 来获取函数的return返回值,但是要注意下面的一种情况
var=$(foo)
if [ "$?" == "0" ]; then
    echo success
fi
此时,不要在var=$(foo)和if [ "$?" == "0" ]; then之间添加任何语句!否则,$?
获取到将不是$(foo)的return返回值,判断就有问题,特别是不要添加echo调试语句.
换句话来说,这种先执行一个语句,在判断$?的方法不是很可靠,会受到各种影响,下
面就提到声明local变量时可能对$?造成的影响.

三. 函数指针
Bash中可以通过如下的方式来达到类似C语言函数指针的功能.假设该脚本是test.sh
echo_a() { echo aaaa $1; }  # 注意$1后面有一个分号';',少这个分号会报错
echo_b() { echo bbbb $1; }
if [ "$1" == "-a" ]; then
    echo_common=echo_a      # 这里的 echo_a 没有加双引号
elif [ "$1" == "-b" ]; then
    echo_common="echo_b"    # 上面的echo_a没加双引号,这里加了.实际上,可加,
else                        # 也可不加,都可以正确执行.
    echo ERROR; exit 1
fi
${echo_common} common
则执行./test.sh -a, 会输出aaaa common, 执行.test.sh -b, 会输出bbbb common.

四. 函数内执行cd命令
在函数里面执行 cd 命令,切换到某个目录后,函数退出时,当前工作目录还是会保持
在那个目录,而不会自动恢复当前工作目录,需要手动执行 cd - 在切换回去.
假设有一个脚本test.sh,里面的内容如下:
cd_to_root() { cd /; }
echo "now, the pwd is: $(pwd)"
cd_to_root
echo "after execute the cd_to_root, pwd is: $(pwd)"
则执行./test.sh, 会输出:
now, the pwd is: /home/john/source/test
after execute the cd_to_root, pwd is: /
由上可见,如果在函数里面执行过cd命令,函数退出时,当前工作目录还是cd后的目录.

五. 声明函数内局部变量
为了避免同名变量造成影响,函数内的变量最好声明为局部变量,使用local来声明.
在Bash中,没有明确用local来声明的变量都是全局变量,即使定义在函数内部也一样.
local [option] [name[=value] ...]
    For each argument, a local variable named name is created, and assigned
    value. The option can be any of the options accepted by declare. When
    local is used within a function, it causes the variable name to have a
    visible scope restricted to that func‐tion and its children. With no
    operands, local writes a list of local variables to the standard output.
    It is an error to use local when not within a function. The return
    status is 0 unless local is used outside a function, an invalid name is
    supplied, or name is a readonly variable.
但是要注意一点. local 命令本身会返回一个值, 假设有个脚本test.sh,如下:
foo() { return 1; }
bar() {
    ret=$(foo); echo first: $?
    local var=$(foo); echo second: $?
}
foobar() { return 0; }
bar
local out=$(foobar); echo third: $?
则执行./test.sh,会输出:
first: 1
second: 0
./test.sh: 第 x 行:local: 只能在函数中使用
third: 1
当不加local命令时,执行foo()函数,得到的$?是1,但是加了local命令后,执行foo()
函数,得到的$?却是0,而foo()函数明明返回的是1. 当local命令在函数外执行时,它
会报错,可以看到虽然foobar()函数返回是0,但是第三个echo语句打印的$?是1,正好
是local执行出错时的返回值,也就是说,此时$?不再是所调用函数的返回值,而是local
命令的返回值.所以先执行一条语句,再用$?来判断函数的return返回值时,注意这种
情况. 为了避免这种情况,最好在函数开头就用local命令声明所有局部变量. 此时,
用local声明多个变量时,变量之间用空格隔开,不要加逗号.例如: local a b c

六. 遍历传入的所有函数参数
当函数接收多个参数时,为了方便获取所有参数,可以使用一个for循环来遍历所有参
数.在Bash中,"$@"会扩展为参数本身的列表,但不包括$0.举例如下:
$function show
> {
> for arg in "$@"; do
> echo $arg
> done
> }
$show 1 2 3
1
2
3
实际上,如果想遍历所有函数参数,并把这些参数赋值给其他变量,那么是不需要for循
环的,直接通过$1, $2, ... $n的方式来引用即可.如果只传入两个参数,然后引用$3也
不会问题,将会返回空.举例如下:
$function show
> {
> echo $1       # 直接使用 $1, $2, $3 来引用函数参数
> echo $2
> echo $3
> }
$show 1         # 调用 show() 函数,并只传入一个参数.可以看到,该函数执行
1               # 正常.虽然 $2 和 $3 并不存在,但是不报错,而是返回"".


$show 1 2 3 4   # 调用 show() 函数,传入四个参数,则只输出传入的前三个参数,
1               # 第四个参数没有被处理.
2
3
